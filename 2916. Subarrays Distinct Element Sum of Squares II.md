# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Using Dynamic Programming to solve this problem, and using Segment Tree to improve the efficiency of range update in array.

# Approach
<!-- Describe your approach to solving the problem. -->
This solution is a Dynamic Programming algorithm. I use a vector `count` to record the distinct counts of all subarrays.
### Code:
```cpp
class Solution {
public:
    vector<ll> count, sq_count;
    void Update(int left, int right, ll val){
        int i;
        for(i=left; i<=right; i++){
            sq_count[i] += (2 * count[i]) % mod + 1;
            sq_count[i] %= mod;
            count[i] += val % mod;
            count[i] %= mod;
        }
    }

    int sumCounts(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, int> last_idx;
        count.resize(n, 0);
        sq_count.resize(n, 0);
        ll result = 0;

        int i, j;
        for(i = 0; i < n; i++){
            if(last_idx.find(nums[i])==last_idx.end())
                last_idx[nums[i]] = -1;
            Update(last_idx[nums[i]]+1, i, 1);
            last_idx[nums[i]] = i;
            for(j = 0; j <= i; j++){
                result = (result + sq_count[j]) % mod;
            }
        }

        count.clear();
        count.shrink_to_fit();
        sq_count.clear();
        sq_count.shrink_to_fit();

        return result;
    }
};
```
In the solution above, the complexity is $O(n^2)$, which is inefficient and consequently cause **Time Limit Exceeded**. So I have rewritten the DP algorithm above into Segment Tree version with Lazy propagation, thus improving the time comsumption of range updating in vectors.
# Additional Information
1. I'd tried 2 types of containers `vector` and `unordered_map` to store the *last time seen idx*. And the result showed that unordered_map is slightly better than vector.  

# Complexity
*n : number of nodes*
- Time complexity: $O(n\log n)$, due to balance binary tree and Lazy propagation.
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: ***O(n)***
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code
```cpp
# define mod 1000000007
# define ll long long
# ifndef TREE_SPEC
    # define ROOT           1
    # define LeftChild(x)   ((x)<<1)
    # define RightChild(x)  (((x)<<1)|1)
# endif

class SegmentTree{
public:
    vector<ll> count, sq_count, lazy;
    SegmentTree(int n){
        count.resize(4*n, 0);
        sq_count.resize(4*n, 0);
        lazy.resize(4*n, 0);
    }
    ~SegmentTree(){
        count.clear();
        count.shrink_to_fit();
        sq_count.clear();
        sq_count.shrink_to_fit();
        lazy.clear();
        lazy.shrink_to_fit();
    }
    void Update(int node, ll L_bound, ll R_bound, ll val){
        sq_count[node] += ((R_bound - L_bound + 1) * val * val) % mod + (2 * count[node] * val) % mod;
        sq_count[node] %= mod;
        count[node] += ((R_bound - L_bound + 1) * val) % mod;
        count[node] %= mod;
    }
    void LazyUpdate(int node, ll L_bound, ll R_bound, ll left, ll right, ll val){
        if(lazy[node] != 0){
            Update(node, L_bound, R_bound, lazy[node]);
            if(L_bound != R_bound){
                lazy[LeftChild(node)] += lazy[node];
                lazy[RightChild(node)] += lazy[node];
            }
            lazy[node] = 0;
        }
        if(R_bound < left || L_bound > right || L_bound > R_bound)
            return;
        if(L_bound >= left && R_bound <= right){
            Update(node, L_bound, R_bound, val);
            if(L_bound != R_bound){
                lazy[LeftChild(node)] += val;
                lazy[RightChild(node)] += val;
            }
            return;
        }
        ll mid = ((L_bound+R_bound)>>1);
        LazyUpdate(LeftChild(node), L_bound, mid, left, right, val);
        LazyUpdate(RightChild(node), mid+1, R_bound, left, right, val);
        sq_count[node] = (sq_count[LeftChild(node)] + sq_count[RightChild(node)]) % mod;
        count[node] = (count[LeftChild(node)] + count[RightChild(node)]) % mod;
    }
};

class Solution {
public:
    int sumCounts(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, int> last_idx;
        SegmentTree SegTree(n);
        int i;
        ll result = 0;
        for(i = 0; i < n; i++){
            if(last_idx.find(nums[i])==last_idx.end())
                last_idx[nums[i]] = -1;
            SegTree.LazyUpdate(ROOT, 0, n-1, last_idx[nums[i]]+1, i, 1);
            last_idx[nums[i]] = i;
            result = (result + SegTree.sq_count[ROOT]) % mod;
        }
        return result;
    }
};

```

# Intuition

# Additional Information

# Complexity
- Time complexity:
  - $$O(log(X))$$ for `numberOfWays()`
  - $$O(N ^ 2)$$ for `buildDP()`
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: $$O(X * N ^ 2)$$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code
```cpp
# define MODS 1000000007
# define MAX_N 301
# define MAX_X 5

class Solution {
private:
    static bool init;
    static vector<vector<vector<int>>> dp;

public:
    long long modPower(long long base, long long exp) {
        long long res = 1;
        while( exp ) {
            if( exp & 1 ) res = (res * base) % MODS;
            base = (base * base) % MODS;
            exp >>= 1;
        }
        return res;
    }

    void buildDP(int x) {
        for( int i = 1; i < MAX_N; ++i ) {
            int curr_pow = modPower(i, x + 1);
            curr_pow = min(curr_pow, MAX_N);
            
            for( int j = 0; j < curr_pow; ++j ) 
                dp[x][i][j] = dp[x][i - 1][j];

            for( int j = curr_pow; j < MAX_N; ++j ) 
                dp[x][i][j] = (dp[x][i - 1][j] + dp[x][i - 1][j - curr_pow]) % MODS;
            
        }
    }

    Solution() {
        if( !init ) {
            init = true;
            for( int k = 0; k < MAX_X; ++k ) {
                dp[k][0][0] = 1;
                buildDP(k);
            }
        }
    }

    int numberOfWays(int n, int x) {
        int x_root = (int)( pow( n, 1.0/x ) );
        if( modPower(x_root + 1, x) == n ) x_root++;

        return dp[x - 1][x_root][n];
    }
};

bool Solution::init = false;
vector<vector<vector<int>>> Solution::dp(MAX_X, vector<vector<int>>(MAX_N, vector<int>(MAX_N)));
```
